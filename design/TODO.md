TODO
====

* Change the DE optimizers and RandomSearcher over to column-major order for individuals like NES uses. This is what we will use form now on since it is Julia's default and might give some speed benefits.

* Implement search space bounding via fitness penalty instead of explicit bounding. The latter is messy and not clear what is the right way to bound. Instead we use fitness(x) = fitness(feasible(x)) + alpha * norm(x - feasible(x), 2) where alpha is 1e-3 or similar, i.e. we penalize going outside the box. This is more general and simpler. Update DE code accordingly.

* Change the interface to the ask method. It should return a tuple (population, indices) where the population is an Array{Float64,2} with each column being one candidate in the population (which is just a set of candidates) and indices being the integer indices to the columns/candidates that should be evaluated. This way we need not extract candidates to send them along but can just pass by reference. Similarly we change the interface to tell so that it takes an array of tuples (index, fitness) where the fitness value may not be relevant but the order of the tuples gives an ordering of the candidates that ask returned. Thus we tell the optimizer which candidates are preferred. Optimizers should generally try to avoid relying on the actual fitness value, rather use some fitness shaping for how to map the ranked list of candidates into utility/weight values.